// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(Ord) {
  var root = function (param) {
    return param[0];
  };
  var rank = function (param) {
    return param[1];
  };
  var link = function (t1, t2) {
    var x2 = t2[0];
    var x1 = t1[0];
    var c = Curry._2(Ord[/* compare */0], x1, x2);
    if (c <= 0) {
      return /* Node */[
              x1,
              t1[1] + 1 | 0,
              /* :: */[
                t2,
                t1[2]
              ]
            ];
    } else {
      return /* Node */[
              x2,
              t2[1] + 1 | 0,
              /* :: */[
                t1,
                t2[2]
              ]
            ];
    }
  };
  var ins = function (_t, _ts) {
    while(true) {
      var ts = _ts;
      var t = _t;
      if (ts) {
        var t$prime = ts[0];
        if (rank(t) < rank(t$prime)) {
          return /* :: */[
                  t,
                  ts
                ];
        } else {
          _ts = ts[1];
          _t = link(t, t$prime);
          continue ;
        }
      } else {
        return /* :: */[
                t,
                /* [] */0
              ];
      }
    };
  };
  var is_empty = function (ts) {
    return ts === /* [] */0;
  };
  var add = function (x, ts) {
    return ins(/* Node */[
                x,
                0,
                /* [] */0
              ], ts);
  };
  var union = function (ts, ts$prime) {
    if (ts) {
      if (ts$prime) {
        var ts2 = ts$prime[1];
        var t2 = ts$prime[0];
        var ts1 = ts[1];
        var t1 = ts[0];
        if (rank(t1) < rank(t2)) {
          return /* :: */[
                  t1,
                  union(ts1, /* :: */[
                        t2,
                        ts2
                      ])
                ];
        } else if (rank(t2) < rank(t1)) {
          return /* :: */[
                  t2,
                  union(/* :: */[
                        t1,
                        ts1
                      ], ts2)
                ];
        } else {
          return ins(link(t1, t2), union(ts1, ts2));
        }
      } else {
        return ts;
      }
    } else {
      return ts$prime;
    }
  };
  var find_min = function (param) {
    if (param) {
      var ts = param[1];
      var t = param[0];
      if (ts) {
        var x = find_min(ts);
        var c = Curry._2(Ord[/* compare */0], root(t), x);
        if (c < 0) {
          return root(t);
        } else {
          return x;
        }
      } else {
        return root(t);
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var lookup_min = function (t) {
    try {
      return /* Some */[find_min(t)];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var get_min = function (param) {
    if (param) {
      var ts = param[1];
      var t = param[0];
      if (ts) {
        var match = get_min(ts);
        var t$prime = match[0];
        var c = Curry._2(Ord[/* compare */0], root(t), root(t$prime));
        if (c < 0) {
          return /* tuple */[
                  t,
                  ts
                ];
        } else {
          return /* tuple */[
                  t$prime,
                  /* :: */[
                    t,
                    match[1]
                  ]
                ];
        }
      } else {
        return /* tuple */[
                t,
                /* [] */0
              ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lwt_pqueue.ml",
              91,
              17
            ]
          ];
    }
  };
  var remove_min = function (ts) {
    if (ts) {
      var match = get_min(ts);
      return union(Curry._1(List.rev, match[0][2]), match[1]);
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var size = function (l) {
    var sizetree = function (param) {
      return 1 + size(param[2]) | 0;
    };
    return Curry._3(List.fold_left, (function (s, t) {
                  return s + sizetree(t) | 0;
                }), 0, l);
  };
  return /* module */[
          /* empty : [] */0,
          /* is_empty */is_empty,
          /* add */add,
          /* union */union,
          /* find_min */find_min,
          /* lookup_min */lookup_min,
          /* remove_min */remove_min,
          /* size */size
        ];
}

exports.Make = Make;
/* No side effect */
