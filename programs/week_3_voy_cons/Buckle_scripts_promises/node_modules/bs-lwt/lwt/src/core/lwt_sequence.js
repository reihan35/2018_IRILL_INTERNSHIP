// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Empty = Caml_exceptions.create("Lwt_sequence.Empty");

function get(node) {
  return node[/* node_data */2];
}

function set(node, data) {
  node[/* node_data */2] = data;
  return /* () */0;
}

function remove(node) {
  if (node[/* node_active */3]) {
    node[/* node_active */3] = false;
    node[/* prev */0][/* next */1] = node[/* next */1];
    node[/* next */1][/* prev */0] = node[/* prev */0];
    return /* () */0;
  } else {
    return 0;
  }
}

function create() {
  var seq = [];
  seq[0] = seq;
  seq[1] = seq;
  return seq;
}

function is_empty(seq) {
  return seq[/* next */1] === seq;
}

function length(seq) {
  var _curr = seq[/* next */1];
  var _len = 0;
  while(true) {
    var len = _len;
    var curr = _curr;
    if (curr === seq) {
      return len;
    } else if (curr[/* node_active */3]) {
      _len = len + 1 | 0;
      _curr = curr[/* node_next */1];
      continue ;
    } else {
      _curr = curr[/* node_next */1];
      continue ;
    }
  };
}

function add_l(data, seq) {
  var node = /* record */[
    /* node_prev */seq,
    /* node_next */seq[/* next */1],
    /* node_data */data,
    /* node_active */true
  ];
  seq[/* next */1][/* prev */0] = node;
  seq[/* next */1] = node;
  return node;
}

function add_r(data, seq) {
  var node = /* record */[
    /* node_prev */seq[/* prev */0],
    /* node_next */seq,
    /* node_data */data,
    /* node_active */true
  ];
  seq[/* prev */0][/* next */1] = node;
  seq[/* prev */0] = node;
  return node;
}

function take_l(seq) {
  if (seq[/* next */1] === seq) {
    throw Empty;
  } else {
    var node = seq[/* next */1];
    remove(node);
    return node[/* node_data */2];
  }
}

function take_r(seq) {
  if (seq[/* next */1] === seq) {
    throw Empty;
  } else {
    var node = seq[/* prev */0];
    remove(node);
    return node[/* node_data */2];
  }
}

function take_opt_l(seq) {
  if (seq[/* next */1] === seq) {
    return /* None */0;
  } else {
    var node = seq[/* next */1];
    remove(node);
    return /* Some */[node[/* node_data */2]];
  }
}

function take_opt_r(seq) {
  if (seq[/* next */1] === seq) {
    return /* None */0;
  } else {
    var node = seq[/* prev */0];
    remove(node);
    return /* Some */[node[/* node_data */2]];
  }
}

function transfer_l(s1, s2) {
  s2[/* next */1][/* prev */0] = s1[/* prev */0];
  s1[/* prev */0][/* next */1] = s2[/* next */1];
  s2[/* next */1] = s1[/* next */1];
  s1[/* next */1][/* prev */0] = s2;
  s1[/* prev */0] = s1;
  s1[/* next */1] = s1;
  return /* () */0;
}

function transfer_r(s1, s2) {
  s2[/* prev */0][/* next */1] = s1[/* next */1];
  s1[/* next */1][/* prev */0] = s2[/* prev */0];
  s2[/* prev */0] = s1[/* prev */0];
  s1[/* prev */0][/* next */1] = s2;
  s1[/* prev */0] = s1;
  s1[/* next */1] = s1;
  return /* () */0;
}

function iter_l(f, seq) {
  var _curr = seq[/* next */1];
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr[/* node_active */3]) {
        Curry._1(f, curr[/* node_data */2]);
      }
      _curr = curr[/* node_next */1];
      continue ;
    } else {
      return 0;
    }
  };
}

function iter_r(f, seq) {
  var _curr = seq[/* prev */0];
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr[/* node_active */3]) {
        Curry._1(f, curr[/* node_data */2]);
      }
      _curr = curr[/* node_prev */0];
      continue ;
    } else {
      return 0;
    }
  };
}

function iter_node_l(f, seq) {
  var _curr = seq[/* next */1];
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr[/* node_active */3]) {
        Curry._1(f, curr);
      }
      _curr = curr[/* node_next */1];
      continue ;
    } else {
      return 0;
    }
  };
}

function iter_node_r(f, seq) {
  var _curr = seq[/* prev */0];
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr[/* node_active */3]) {
        Curry._1(f, curr);
      }
      _curr = curr[/* node_prev */0];
      continue ;
    } else {
      return 0;
    }
  };
}

function fold_l(f, seq, acc) {
  var _curr = seq[/* next */1];
  var _acc = acc;
  while(true) {
    var acc$1 = _acc;
    var curr = _curr;
    if (curr === seq) {
      return acc$1;
    } else if (curr[/* node_active */3]) {
      _acc = Curry._2(f, curr[/* node_data */2], acc$1);
      _curr = curr[/* node_next */1];
      continue ;
    } else {
      _curr = curr[/* node_next */1];
      continue ;
    }
  };
}

function fold_r(f, seq, acc) {
  var _curr = seq[/* prev */0];
  var _acc = acc;
  while(true) {
    var acc$1 = _acc;
    var curr = _curr;
    if (curr === seq) {
      return acc$1;
    } else if (curr[/* node_active */3]) {
      _acc = Curry._2(f, curr[/* node_data */2], acc$1);
      _curr = curr[/* node_prev */0];
      continue ;
    } else {
      _curr = curr[/* node_next */1];
      continue ;
    }
  };
}

function find_node_l(f, seq) {
  var _curr = seq[/* next */1];
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr[/* node_active */3]) {
        if (Curry._1(f, curr[/* node_data */2])) {
          return curr;
        } else {
          _curr = curr[/* node_next */1];
          continue ;
        }
      } else {
        _curr = curr[/* node_next */1];
        continue ;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_node_r(f, seq) {
  var _curr = seq[/* prev */0];
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr[/* node_active */3]) {
        if (Curry._1(f, curr[/* node_data */2])) {
          return curr;
        } else {
          _curr = curr[/* node_prev */0];
          continue ;
        }
      } else {
        _curr = curr[/* node_prev */0];
        continue ;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_node_opt_l(f, seq) {
  try {
    return /* Some */[find_node_l(f, seq)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function find_node_opt_r(f, seq) {
  try {
    return /* Some */[find_node_r(f, seq)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

exports.get = get;
exports.set = set;
exports.remove = remove;
exports.create = create;
exports.is_empty = is_empty;
exports.length = length;
exports.add_l = add_l;
exports.add_r = add_r;
exports.Empty = Empty;
exports.take_l = take_l;
exports.take_r = take_r;
exports.take_opt_l = take_opt_l;
exports.take_opt_r = take_opt_r;
exports.transfer_l = transfer_l;
exports.transfer_r = transfer_r;
exports.iter_l = iter_l;
exports.iter_r = iter_r;
exports.iter_node_l = iter_node_l;
exports.iter_node_r = iter_node_r;
exports.fold_l = fold_l;
exports.fold_r = fold_r;
exports.find_node_opt_l = find_node_opt_l;
exports.find_node_opt_r = find_node_opt_r;
exports.find_node_l = find_node_l;
exports.find_node_r = find_node_r;
/* No side effect */
